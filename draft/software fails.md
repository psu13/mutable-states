On the one hand, I think that for a lot of things it's a stretch to call programming any sort of "engineering"

On the other hand, I think that for a lot of things it's also a stretch to call what we usually call "engineering" by that name.

People tend to point to surface level things in software, like lack of polish, or dumb detail bugs that never got fixed, as indicates that the engineering is sloppy ... but these things happen in all large systems, some of which are a lot simpler than what software people put together (buildings, houses, planes).

I think the ways that software continues to fall down are more conceptual and abstract ...

1. programmers seem to behave like memory-less markov chains, jumping from failed big idea to failed big idea, with no apparent notion that the failed idea that they are about to latch on to already failed to be the silver bullet 25 years ago (OO!, agile!, test driven development!,  whatever).

2. the economics of commercial software development still favor shipping features fast rather than being able to spend sufficient time to get the foundations right. i think in principle we understand those foundations and tradeoffs a lot better now than we did in the 80s. but to make an actual living at this you have to ship on shorter and shorter cycles (when iWork started, we did 2 year cycles for a major release + a few dots. now we do 3 releases a year ... Office 365 claims to do releases every month or some shit).

3. the thing that Brooks said about the complexity of software being inherent rather than emergent is still apt.  I guess he said essential and not accidental. we continue to be in a place where the difference between the implementation of system A system B, even though they look very similar structurally, will be completely and utterly different internally for various reasons of detail and historical dependencies.


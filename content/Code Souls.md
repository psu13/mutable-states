Title: Code Souls
Date: 2020-04-25
Category: Computers
Author: psu

It occurred to me, while sitting in my house accompanied mostly by my own thoughts (1), that I have been programming computers for money in one way or another for almost forty years. When presented with a fact like this, one is lead to wonder: what kind of brain damage does one have to have to end up in a situation like this? I don't really know *all* the answers. But I will suggest one simple test here.

If you are wondering to yourself: "will I enjoy programming computers as a job over the long term?" and you want to get a shallow, but probably accurate approximate answer there is one simple thing you can do: run out and buy a copy of *Dark Souls* and see if you enjoy playing through it solo (2).

Long time readers of this web site will be familiar with <a href="http://mutable-states.com/dark-souls-ate-my-brain.html">the chronicles of my obsession with the *Souls*-style video games</a>.

To review: *Demon's Souls*, *Dark Souls*, *Dark Souls 2*, *Dark Souls 3*, *Bloodborne* and *Sekiro* are a series of third person action RPG/dungeon crawlers where you take a character through some horrible world which is full of various creatures who are out to kill you. While the games differ somewhat in style and tone and polish they all have a similar structure. Their worlds are usually dead or in the process of dying. So there usually is not a lot of *character*-driven plot going on. All that happens is what you do. They emphasize combat, though not necessarily fast twitch skills (I assume, since I have none). Some say they are "hard", but I tend to say that they are relatively unforgiving of inevitable lapses in focus or judgement. Finally, to play them you better enjoy the mechanics, because you are always in for a lot of repetition.

It is the combination of failure and repetition that makes *Souls* like programming of all kinds. Here is what I mean.

When you write computer programs you will tend to go through a series of steps:

1. Some group of people have an idea for something they want to do automatically.
2. They get together and talk about it and figure out that it could be a good computer program.
3. They then talk to a programmer to translate their desires into some list of things that a programmer can encode as code.
4. *Programmers writes code*
5. Now they try the code out, and it's completely wrong.
6. More talking.
7. *Programmers writes code*
8. More failure.
9. More talking.
10. ...
11. Eventually the program becomes some approximation of what everyone thought they wanted in the first place.
12. Send the code out to users.
13. Users complain that the program is completely wrong.
14. ...
15. GOTO 1

If you program computers for a long time the one thing you learn is that no matter what you do the time you spend *fixing* things will greatly dominate the time you spend doing almost anything else related to any product. Decades of experience and study have produced innumerable schemes (OO design!, Test Driven Development!, Xtreme Programming!, Agile!, Strong type systems!), methodologies (OO design!, Test Driven Development!, Xtreme Programming!, Agile!, Strong type systems!), and process cults (OO design!, Test Driven Development!, Xtreme Programming!, Agile!, Strong type systems!) all of which have ultimately failed to make a significant dent in this fact.

If you write programs you will fail fail fail and fail some more. Then eventually it will work well enough to use. Then you will try to add things and go back to the failure cycle all over again.

This is, of course, a little depressing. After all, most programming nerds got *into* the game in the first place because it promised the ability to have total control and autonomy over a predictable and deterministic system. Oh how naive we all were. Still, we stay in the game because most of the work that goes into those bits between the failures is just the kind of intricate puzzle solving that tickles just the right brain centers to keep us going.

All of that aside ... does the above structure *remind you of anything*? I'll list the steps again more compactly:

1. You are told something that you have to do.
2. You study the problem, and come up with a possible solution.
3. You try out the solution, and it fails miserably.
4. You rethink.
5. You fail.
6. ...
7. GOTO 4

Or maybe

1. You are told you have to defeat a difficult boss monster.
2. You study the problem, and come up with a possible solution.
3. You try out the solution, and it fails miserably.
4. You rethink.
5. You fail.
6. ...
7. GOTO 4

This then, is why I think *Dark Souls* is a good preparation for a career in computer programming. It encapsulates the fundamental cycle of systematic and repeated failure that you will be in for once you get your dream job. For some reason I feel this similarity most often when I am fighting *Souls* bosses that are on fire.

So we have this guy:

> <iframe width="560" height="315" src="https://www.youtube.com/embed/V2F0plmqo-w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

Teaching the importance of trusting your tools.

And this guy

> <iframe width="560" height="315" src="https://www.youtube.com/embed/hiFQvChlNcE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

Reminding you that the system APIs will not always behave the way you expect them to, no matter what they might have done in the past.

All of this seems hopeless, but if you stick with it and learn the right lessons, the *Souls* games give you an unprecedented opportunity to go from zero:

> <iframe width="560" height="315" src="https://www.youtube.com/embed/EPzVEnuXCEE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

to not a bad hero:

> <iframe width="560" height="315" src="https://www.youtube.com/embed/LqYJxvNg5GY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

All it takes is a small amount of skill, and a large amount of practice and pigheaded stubbornness. 

And so it is with programming as well. I firmly believe that anyone can program computers if they want to. And it's not because we programmers have built a galaxy of incredible tools that make it easy to observe, explain, and conquer the problems that you will face when you try. We haven't. The tools mostly suck, and they sit on top of ecosystems and runtimes that all grew up in a weird ad-hoc semi-organic but also semi-cancerous way that makes no sense unless you know the full history of everything. Still, all of these things are conquerable if you have a small amount of skill, and a large amount of practice and pigheaded stubbornness.

Which brings me to my latest stupid project. I never managed to figure out how to beat this fire boss from *Bloodborne* in my BL4 (no leveling) run:

> <iframe width="560" height="315" src="https://www.youtube.com/embed/2FA2UMrB8qg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

So I'm trying again. And it's going really well:

> <iframe width="560" height="315" src="https://www.youtube.com/embed/ARQV0RW--IE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

I should have it in no time ... or at least by the time the world opens up again in 2022.

### Foonotes

1. For readers from the distant future, this page was written during the COVID-19 lockdown, where a lot of people had a lot of time to sit in their homes with mostly their thoughts to keep them company. Was an interesting time. Would not recommend.

1. Of course this is an approximate test. I know plenty of programmers who don't like *Dark Souls*. 
